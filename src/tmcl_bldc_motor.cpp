/**
 * Copyright (c) 2022 Analog Devices, Inc. All Rights Reserved.
 * This software is proprietary to Analog Devices, Inc. and its licensors.
 **/

#include "tmcl_bldc_motor.h"

////////////////////////////////////////////////////////////////////////////////

/* Constructor */
BLDCMotor::BLDCMotor(ros::NodeHandle *p_nh, TmclInterpreter* p_tmcl_int, uint8_t motor_num)  :  
Motor(p_nh, p_tmcl_int, motor_num)
{
  b_statusflags_register_available = true;

  ROS_DEBUG_STREAM("[BLDCMotor::" <<  __func__ << "] called");

  /* Save StatusFlags RegisterNames and StatusFlags RegisterShift to vector */
  const std::string s_statusflags_reg_name = s_node_name + "/StatusFlags_Reg_name";
  if(!p_nh_->getParam(s_statusflags_reg_name, param_statusflags_reg_name))
  {
    b_statusflags_register_available = false;
    ROS_WARN_STREAM("[" <<  __func__ << "] StatusFlags Register Names are not available.");
  }
  const std::string s_statusflags_reg_shift = s_node_name + "/StatusFlags_Reg_shift";
  if(b_statusflags_register_available && !p_nh_->getParam(s_statusflags_reg_shift, param_statusflags_reg_shift))
  {
    b_statusflags_register_available = false;
    ROS_WARN_STREAM("[" <<  __func__ << "] StatusFlags Register Shift are not available.");
  }

  /* Check if Reg name and Reg shift vectors have the same length/size */
  if(b_statusflags_register_available && (param_statusflags_reg_name.size() != param_statusflags_reg_shift.size()))
  {
    b_statusflags_register_available = false;
    ROS_WARN_STREAM("[" <<  __func__ << "] Missing index for StatusFlagsRegisterName / StatusFlagsRegisterShift. Check autogenerated YAML. StatusFlags wont be used!");
  }
}

/* Destructor */
BLDCMotor::~BLDCMotor()
{
  ROS_DEBUG_STREAM("[BLDCMotor::" <<  __func__ << "] called");
}

void BLDCMotor::init()
{
  int32_t val = 0;

  ROS_INFO_STREAM("[BLDCMotor::" << __func__ << "] called");

  if(p_tmcl_int->executeCmd(TMCL_CMD_GAP, "CommutationMode", motor_num, &val))
  {
    comm_mode = (bldc_comm_mode_t) val;
  }
  else
  {
    comm_mode = BLDC_DISABLED_MOTOR;
    ROS_WARN_STREAM("[" << __func__ << "] \"CommutationMode\" is not available. Setting CommutationMode to Disable");
  }

  if(p_tmcl_int->executeCmd(TMCL_CMD_GAP, "PositionScalerM", motor_num, &val))
  {
    position_scaler = val;
  }
  else
  {
    position_scaler = 0;
    ROS_WARN_STREAM("[" << __func__ << "] \"PositionScalerM\" is not available");

    if(comm_mode >= BLDC_CLOSEDLOOP_MOTOR && p_tmcl_int->executeCmd(TMCL_CMD_GAP, "EncoderSteps", motor_num, &val))
    {
      encoder_steps = val;
    }
    else
    {
      encoder_steps = 0;
      ROS_WARN_STREAM("[" << __func__ << "] \"EncoderSteps\" is not available.");
    }
  }

  /* Print units of each commands */
  if(param_wheel_diameter == 0)
  {
    ROS_INFO_STREAM("[" << __func__ << "] Velocity unit: rpm");
  }
  else
  {
    ROS_INFO_STREAM("[" << __func__ << "] Velocity unit: m/s");
  }
  if(position_scaler == 0 && encoder_steps == 0)
  {
    ROS_INFO_STREAM("[" << __func__ << "] Position unit: pulses");
  }
  else
  {
    ROS_INFO_STREAM("[" << __func__ << "] Position unit: angular degrees");
  }
  
  ROS_INFO_STREAM("[" << __func__ << "] Torque unit: mA");

  initPublisher();
  this->initSubscriber();
  ROS_INFO("[%s] Motor %d Initialized!\n", __func__, motor_num);
}

/* Publisher Callback */
void BLDCMotor::rosPublishTmcInfo(const ros::TimerEvent& event)
{
  int32_t val = 0;
  int32_t status_flag = 0;
  uint8_t bin_index = 0;
  uint8_t array_index = 0;
  std::string binary = " ";
  std::string status = " ";

  tmc_info_msg.header.stamp = ros::Time::now();
  tmc_info_msg.header.seq = seq_ctr;
  tmc_info_msg.header.frame_id = s_node_name + "/motor" + std::to_string(motor_num) + "/tmcl_frame";
  tmc_info_msg.interface_name = param_comm_interface_name;
  tmc_info_msg.motor_num = motor_num;

  /* Initialize messages to 0 first */
  tmc_info_msg.board_voltage = 0;
  tmc_info_msg.status_flag = 0;
  tmc_info_msg.velocity = 0;
  tmc_info_msg.position = 0;
  tmc_info_msg.torque = 0;

  if(p_tmcl_int->executeCmd(TMCL_CMD_GAP, "SupplyVoltage", motor_num, &val))
  {
    tmc_info_msg.board_voltage = val / 10; //converts mV to V
  }
  else
  {
    ROS_DEBUG_STREAM("[" << __func__ << "] Failed to get SupplyVoltage");
  }

  if(p_tmcl_int->executeCmd(TMCL_CMD_GAP, "StatusFlags", motor_num, &val))
  {
    tmc_info_msg.status_flag = val;
    status_flag = tmc_info_msg.status_flag;
  }
  else
  {
    ROS_DEBUG_STREAM("[" << __func__ << "] Failed to get StatusFlags");
  }

  //Parsing StatusFlags value to display status in string
  if(b_statusflags_register_available)
  {
    while(status_flag)
    {
      if(status_flag & 1)
      {
        binary+='1';
      }
      else
      {
        binary+='0';
      }
      status_flag>>=1;
    }

    for(bin_index = 0; bin_index < binary.length(); bin_index++)
    {
      if(binary[bin_index] == '1')
      {
        while(array_index < param_statusflags_reg_shift.size())
        {
          if(bin_index == param_statusflags_reg_shift[array_index])
          {
            status += param_statusflags_reg_name[array_index - 1] + ", ";
            array_index = 0;
            break;
          }
          array_index++;
        }
      }
    }                    
    tmc_info_msg.status = status; 
  }
  else
  {
    tmc_info_msg.status = "StatusFlags Registers Not Available"; 
  }
 
  /* Velocity, Position, Torque */
  if(param_pub_actual_vel)
  {
    if(p_tmcl_int->executeCmd(TMCL_CMD_GAP, "ActualVelocity", motor_num, &val))
    {
      //converts rpm to linear velocity
      if(param_wheel_diameter == 0)
      {
        tmc_info_msg.velocity = val * param_add_ratio_vel;
      }
      else
      {
        tmc_info_msg.velocity = ((val * PI * param_wheel_diameter) / SECS_TO_MIN) * param_add_ratio_vel;
      }
    }
    else
    {
      ROS_DEBUG_STREAM("[" << __func__ << "] Failed to get ActualVelocity");
    }
  }

  if(param_pub_actual_pos)
  {
    if(p_tmcl_int->executeCmd(TMCL_CMD_GAP, "ActualPosition", motor_num, &val))
    {
      //converts steps to degrees
      if(position_scaler > 0)
      {
        tmc_info_msg.position = ((val * ANGULAR_FULL_ROTATION) / position_scaler) * param_add_ratio_pos;
      }
      else if(encoder_steps > 0)
      {
        tmc_info_msg.position = ((val * ANGULAR_FULL_ROTATION) / encoder_steps) * param_add_ratio_pos;
      }
      else
      {
        tmc_info_msg.position = val * param_add_ratio_pos;
      }
    }
    else
    {
      ROS_DEBUG_STREAM("[" << __func__ << "] Failed to get ActualPosition");
    }
  }

  if(param_pub_actual_trq)
  {
    if(p_tmcl_int->executeCmd(TMCL_CMD_GAP, "ActualTorque", motor_num, &val))
    {
      tmc_info_msg.torque = val * param_add_ratio_trq;
    }
    else
    {
      ROS_DEBUG_STREAM("[" << __func__ << "] Failed to get ActualTorque");
    }
  }

  tmc_info_pub.publish(tmc_info_msg);
  seq_ctr++;
}

/* Initialize Subscriber */
void BLDCMotor::initSubscriber()
{
  ROS_INFO_STREAM("[BLDCMotor::" << __func__ << "] called");

  if(comm_mode == BLDC_OPENLOOP_MOTOR)
  {
    ROS_INFO_STREAM("[" << __func__ << "] CommutationMode : OPENLOOP");
    tmc_cmd_vel_sub = p_nh_->subscribe(param_tmc_cmd_vel_topic, 1000, &BLDCMotor::cmdVelCallback, this);
    tmc_cmd_abspos_sub = p_nh_->subscribe(param_tmc_cmd_abspos_topic, 1000, &BLDCMotor::cmdAbsPosCallback, this);
    tmc_cmd_relpos_sub = p_nh_->subscribe(param_tmc_cmd_relpos_topic, 1000, &BLDCMotor::cmdRelPosCallback, this);
  }
  else if(comm_mode >= BLDC_CLOSEDLOOP_MOTOR)
  {
    ROS_INFO_STREAM("[" << __func__ << "] CommutationMode : CLOSEDLOOP");
    Motor::initSubscriber();
  }
  /* Note: No subscriber if Commutation Mode is Disabled */
}

/* Subscriber Callback */
void BLDCMotor::cmdVelCallback(const geometry_msgs::Twist& msg)
{
  float val = msg.linear.x;
  int32_t board_val = 0;

  //If wheel diameter is set to 0 (or no wheels connected), the input value for linearX is equal to motors rpm 
  if(param_wheel_diameter == 0)
  {
    board_val = val / param_add_ratio_vel;
  }
  else
  {
    //Formula to convert linear value to rpm (unit that the board accepts)
    board_val = ((val * SECS_TO_MIN) / (PI * param_wheel_diameter)) / param_add_ratio_vel;
  }

  ROS_DEBUG_STREAM("[" << __func__ << "] Subscriber callback entered, received: " << val << " board value: " << board_val);

  if(board_val >= 0)
  {
    if(p_tmcl_int->executeCmd(TMCL_CMD_ROR, 0, motor_num, &board_val))
    {
      ROS_DEBUG_STREAM("\n[" << __func__ << "] Subscriber callback exited successfully");
    }
    else
    {
      ROS_ERROR_STREAM("[" << __func__ << "] Failed to set Velocity");
    }
  }
  else
  {
    board_val = abs(board_val);
    if(p_tmcl_int->executeCmd(TMCL_CMD_ROL, 0, motor_num, &board_val))
    {
      ROS_DEBUG_STREAM("\n[" << __func__ << "] Subscriber callback exited successfully");
    }
    else
    {
      ROS_ERROR_STREAM("[" << __func__ << "] Failed to set Velocity");
    }
  } 
}
void BLDCMotor::cmdAbsPosCallback(const std_msgs::Int32 msg)
{
  float convert_const_deg = 0.00;
  int32_t unit_val = 0;
  int32_t val = msg.data;

  //convert input(degrees) to unit
  if(position_scaler > 0)
  {
    convert_const_deg = (position_scaler / (float) ANGULAR_FULL_ROTATION) / param_add_ratio_pos;
  }
  else if(encoder_steps > 0)
  {
    convert_const_deg = (encoder_steps / (float) ANGULAR_FULL_ROTATION) / param_add_ratio_pos;
  }
  else
  {
    //inverting position additional ratio 
    convert_const_deg = 1 / param_add_ratio_pos;
  }

  unit_val = val * convert_const_deg;

  ROS_DEBUG_STREAM("[" << __func__ << "] Subscriber callback entered, received: " << val << " board value: " << unit_val);

  if(p_tmcl_int->executeCmd(TMCL_CMD_MVP, 0, motor_num, &unit_val))
  {
    ROS_DEBUG_STREAM("\n[" << __func__ << "] Subscriber callback exited successfully");
  }
  else
  {
    ROS_ERROR_STREAM("[" << __func__ << "] Failed to set Absolute Position");
  }
}
void BLDCMotor::cmdRelPosCallback(const std_msgs::Int32 msg)
{
  float convert_const_deg = 0;
  int32_t unit_val = 0;
  int32_t val = msg.data;

  //convert input(degrees) to unit
  if(position_scaler > 0)
  {
    convert_const_deg = (position_scaler / (float) ANGULAR_FULL_ROTATION) / param_add_ratio_pos;
  }
  else if(encoder_steps > 0)
  {
    convert_const_deg = (encoder_steps / (float) ANGULAR_FULL_ROTATION) / param_add_ratio_pos;
  }
  else
  {
    //inverting position additional ratio 
    convert_const_deg = 1 / param_add_ratio_pos;
  }

  unit_val = val *  convert_const_deg;

  ROS_DEBUG_STREAM("[" << __func__ << "] Subscriber callback entered, received: " << val << " board value: " << unit_val);

  if(p_tmcl_int->executeCmd(TMCL_CMD_MVP, 1, motor_num, &unit_val))
  {
    ROS_DEBUG_STREAM("\n[" << __func__ << "] Subscriber callback exited successfully");
  }
  else
  {
    ROS_ERROR_STREAM("[" << __func__ << "] Failed to set Relative Position");
  }
}
